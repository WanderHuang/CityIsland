# HTTP协议 #
## HTTP请求 ##
![没有图片](./pics/1.png)
### 请求行 ###
![没有图片](./pics/2.png)  
|结构|URL|HTTP|
|-:|-:|-:|
|a|b|c|
- 结构：[GET | POST | …]  
- URL(资源路径)  
- HTTP协议版本
### 请求头 ###
Accept	指定客户端能够接收的内容类型	Accept: text/plain, text/html
Accept-Charset	浏览器可以接受的字符编码集。	Accept-Charset: iso-8859-5
Accept-Encoding	指定浏览器可以支持的web服务器返回内容压缩编码类型。	Accept-Encoding: compress, gzip
Accept-Language	浏览器可接受的语言	Accept-Language: en,zh
Authorization	HTTP授权的授权证书	Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==
Cache-Control	指定请求和响应遵循的缓存机制	Cache-Control: no-cache
Connection	表示是否需要持久连接。（HTTP 1.1默认进行持久连接）	Connection: close
Cookie	HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。	Cookie: $Version=1; Skin=new;
Content-Length	请求的内容长度	Content-Length: 348
Content-Type	请求的与实体对应的MIME信息	Content-Type: application/x-www-form-urlencoded
Date	请求发送的日期和时间	Date: Tue, 15 Nov 2010 08:12:31 GMT
Host	指定请求的服务器的域名和端口号	Host: www.zcmhi.com
If-Match	只有请求内容与实体相匹配才有效	If-Match: “737060cd8c284d8af7ad3082f209582d”
If-Modified-Since	如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码	If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT
If-None-Match	如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变	If-None-Match: “737060cd8c284d8af7ad3082f209582d”
If-Unmodified-Since	只在实体在指定时间之后未被修改才请求成功	If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT
Referer	先前网页的地址，当前请求网页紧随其后,即来路	Referer: http://www.zcmhi.com/archives/71.html
User-Agent	User-Agent的内容包含发出请求的用户信息，例如：客户端浏览器类型与版本，操作系统等信息	User-Agent: Mozilla/5.0 (Linux; X11)
### 请求正文 ###
请求参数，参数类型符合请求头中设置的Content-Type的类型
## HTTP响应 ##
![没有图片](./pics/3.png)  
### 响应行 ###
> HTTP/1.1 200 OK  

结构：HTTP协议版本       状态码         状态码描述
状态码分类：
![没有图片](./pics/4.png)  
常见状态码：
1开头的状态码
100	Continue	继续。客户端应继续其请求
101	Switching Protocols	切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议
2开头的状态码
200	OK	请求成功。一般用于GET与POST请求
201	Created	已创建。成功请求并创建了新的资源
202	Accepted	已接受。已经接受请求，但未处理完成
3开头的状态码
301	Moved Permanently	永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替
304	Not Modified	未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源
4开头的状态码
400	Bad Request	客户端请求的语法错误，服务器无法理解，例如：参数不匹配
401	Unauthorized	请求要求用户的身份认证
404	Not Found	服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面
405	Method Not Allowed	客户端请求中的方法被禁止
408	Request Time-out	服务器等待客户端发送的请求时间过长，超时
5开头的状态码
500	Internal Server Error	服务器内部错误，无法完成请求
505	HTTP Version not supported	服务器不支持请求的HTTP协议的版本，无法完成处理
### 响应头 ###
Allow	对某网络资源的有效的请求行为，不允许则返回405	Allow: GET, HEAD
Cache-Control	告诉所有的缓存机制是否可以缓存及哪种类型	Cache-Control: no-cache
Content-Encoding	web服务器支持的返回内容压缩编码类型。	Content-Encoding: gzip
Content-Language	响应体的语言	Content-Language: en,zh
Content-Length	响应体的长度	Content-Length: 348
Content-Location	请求资源可替代的备用的另一地址	Content-Location: /index.htm
Content-Type	返回内容的MIME类型	Content-Type: text/html; charset=utf-8
Date	原始服务器消息发出的时间	Date: Tue, 15 Nov 2010 08:12:31 GMT
ETag	请求变量的实体标签的当前值	ETag: “737060cd8c284d8af7ad3082f209582d”
Expires	响应过期的日期和时间	Expires: Thu, 01 Dec 2010 16:00:00 GMT
Last-Modified	请求资源的最后修改时间	Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT
Location	用来重定向接收方到非请求URL的位置来完成请求或标识新的资源	Location: http://www.zcmhi.com/archives/94.html
Server	web服务器软件名称	Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)
Set-Cookie	设置Http Cookie	Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1
### 响应正文 ###
请求结果，格式与Content-Type保持一致。
# Web性能优化 #
![没有图片](./pics/5.png) 
如上图，整个WEB应用其实是一个客户端（浏览器）发送HTTP请求与后台服务器交换数据的过程。所以Web应用的性能优化，可以从客户端、通道（HTTP协议）、服务器三个方面进行优化。
## HTTP性能优化 ##
首先需要明确的是，在一个HTTP请求的发起到响应过程中，客户端和服务器的处理能力并没有想象中的差，所以大部分的时间损耗，其实是发生在建立连接的过程中，所以第一步我们需要掌握的是关于HTTP的性能优化。
### 长连接（针对1.0版本的HTTP） ###
因为HTTP基于TCP协议，TCP包含了三次握手的过程，并且HTTP协议是无状态的，在执行完一次请求之后，就会关闭连接。所以考虑这样一个场景，当客户端需要同时发出多个请求的时候，例如需要同时发送A、B、C、D四个请求，如果可以复用同一条通道，将会减少B、C、D的三次握手过程，从而大大的减少请求时间。实现方式如下：
发送A的时候，请求头的Connection选项设置为keep-alive
发送B的时候，请求头的Connection选项设置为keep-alive
发送C的时候，请求头的Connection选项设置为keep-alive
发送D的时候，请求头的Connection选项设置为close
这样可以节省后续三次请求的连接创建和关闭开销。
### 缓存 ###
客户端浏览器加载服务器中的JS/CSS/HTML/图片等相关静态资源（注意仅限于静态资源文件，不适用于ajax请求接口数据），对于线上产品，这类文件通常都不会有太大的变动，所以如果能有效的利用浏览器的缓存，那么将减少HTTP报文的大小，有效减少请求的开销。概念如下：
为方便理解，我们假设浏览器存在一个缓存数据库,用于存储缓存信息。
在客户端第一次请求数据时，此时缓存数据库中没有对应的缓存数据，需要请求服务器，服务器返回后，将数据存储至缓存数据库中。（现代浏览器均内部实现了此机制）
HTTP缓存有多种规则，根据是否需要向服务器发起请求来分类，可分为两大类：强制缓存、对比缓存。
![没有图片](./pics/6.png) 
强制缓存的使用规则
![没有图片](./pics/7.png) 
对比缓存的使用规则
可以看到两类缓存规则的不同，强制缓存如果生效，不需要再和服务器发生交互，而对比缓存不管是否生效，都需要与服务端发生交互。两类缓存规则可以同时存在，强制缓存优先级高于对比缓存，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行对比缓存规则。
#### 强制缓存 ####
从上面我们知道，强制缓存，在缓存数据未失效的情况下，可以直接使用缓存数据，那么浏览器是如何判断缓存数据是否失效呢？	
在没有缓存数据的时候，浏览器向服务器请求数据时，服务器会将数据和缓存规则一并返回，缓存规则信息包含在响应报文的header中。对于强制缓存来说，响应报文header中会有两个字段来标明失效规则（Expires/Cache-Control）使用chrome的开发者工具，可以很明显的看到对于强制缓存生效时，网络请求的情况：
 
* Expires（有效期截止时间）
　 Expires的值为服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。不过Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。
    另一个问题是，到期时间是由服务端生成的，但是客户端时间可能跟服务端时间有误差，这就会导致缓存命中的误差。所以HTTP 1.1 的版本，使用Cache-Control替代。
* Cache-Control
    Cache-Control 是最重要的规则。常见的取值有private、public、no-cache、max-age，no-store，默认为private。
private:	客户端可以缓存
public:	客户端和代理服务器都可缓存（前端的同学，可以认为public和private是一样的）
max-age=xxx:	缓存的内容将在 xxx 秒后失效
no-cache:		需要使用对比缓存来验证缓存数据（后面介绍）
no-store:	所有内容都不会缓存
#### 对比缓存 ####
浏览器第一次请求数据时，服务器将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库中。
再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回304状态码，通知客户端比较成功，可以使用缓存数据。否则返回200状态码，以及缓存标识、数据。
![没有图片](./pics/8.png) 
通过两图的对比，我们可以很清楚的发现，在对比缓存生效时，状态码为304，并且报文大小和请求时间大大减少。
原因是，服务端在进行标识比较后，只返回header部分，通过状态码通知客户端使用缓存，不再需要将报文主体部分返回给客户端。
对于对比缓存来说，缓存标识的传递是我们着重需要理解的，它在请求header和响应header间进行传递，一共分为两类标识传递，接下来，我们分开介绍。
Last-Modified  /  If-Modified-Since（根据修改时间对比缓存）
Last-Modified：
服务器在响应请求时，告诉浏览器资源的最后修改时间。
![没有图片](./pics/9.png) 
If-Modified-Since：
再次请求服务器时，通过此字段通知服务器上次请求时，服务器返回的资源最后修改时间。
服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。
若资源的最后修改时间大于If-Modified-Since，说明资源又被改动过，则响应整片资源内容，返回状态码200；
若资源的最后修改时间小于或等于If-Modified-Since，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。
否则响应HTTP 200，返回数据和Last-Modified	(最后修改时间)标识
![没有图片](./pics/10.png) 
Etag  /  If-None-Match（优先级高于Last-Modified  /  If-Modified-Since）
Etag：
服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。
![没有图片](./pics/11.png) 
If-None-Match：
再次请求服务器时，通过此字段通知服务器客户段缓存数据的唯一标识。
服务器收到请求后发现有头If-None-Match 则与被请求资源的唯一标识进行比对，
不同，说明资源又被改动过，则响应整片资源内容，返回状态码200和Etag标识；
相同，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。
![没有图片](./pics/12.png) 
总结
1、	对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。
2、	对于比较缓存，将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。
### 采用高版本HTTP协议 ###
	通常所说的HTTP协议，指的是HTTP1.0、HTTP1.1以及最新的HTTP2，HTTP协议在升级的过程中，对性能的优化也越来越好，所以可以采用支持高版本HTTP协议的应用服务器搭建服务。
#### HTTP1.0对比HTTP1.1 ####
长连接（非常重要）
HTTP 1.0需要使用keep-alive参数来告知服务器端要建立一个长连接，而HTTP1.1默认支持长连接。
HTTP是基于TCP/IP协议的，创建一个TCP连接是需要经过三次握手的,有一定的开销，如果每次通讯都要重新建立连接的话，对性能有影响。因此最好能维持一个长连接，可以用1个长连接来发多个请求。
------
节约带宽（非常重要）
HTTP 1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接受到100，才开始把请求body发送到服务器。这样当服务器返回401的时候，客户端就可以不用发送请求body了，节约了带宽。
另外HTTP1.1还支持传送内容的一部分。这样当客户端已经有一部分的资源后，只需要跟服务器请求另外的部分资源即可。这是支持文件断点续传的基础。
------
HOST域
现在可以web server例如tomat，设置虚拟站点是非常常见的，也即是说，web server上的多个虚拟站点可以共享同一个ip和端口。
HTTP1.0是没有host域的，HTTP1.1才支持这个参数。
#### HTTP1.1对比HTTP2 ####
多路复用(非常重要)
HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。
当然HTTP1.1也可以多建立几个TCP连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。
TCP连接有一个预热和保护的过程，先检查数据是否传送成功，一旦成功过，则慢慢加大传输速度。因此对应瞬时并发的连接，服务器的响应就会变慢。所以最好能使用一个建立好的连接，并且这个连接可以支持瞬时并发的请求。
-----
数据压缩（重要）
HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。
-----
服务器推送
意思是说，当我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源。
## 客户端优化 ##
### 减少DOM操作 ###
	前端在运行的过程中，其实JS的耗时是非常少的，更多的时候，是在进行DOM的重绘和重排操作，所以这也是现在的主流MVVM框架，使用Virtual DOM的原因，本质上就是在内存中，用JS对象构建一颗虚拟的关系树，在状态变更之后，先改变内存中的js对象，然后再映射到真实的DOM树中（这样可以做到最少的DOM操作）。
### 尽可能使用异步取代同步 ###
#### JS脚本的加载优化 ####
	JavaScript脚本的加载，默认情况下是会阻塞整个DOM的渲染的，之所以这样设计，是因为JS中可能存在一些对DOM的操作，甚至重定向问题，所以同步的加载执行被认为才是安全的。
1、	最简单的优化，就是将<script>标签放在页面末尾</body>之前，这样尽可能减少这种阻塞行为，而先让页面展示出来。
2、	使用<script defer></script>属性，注意：defer属性表明此脚本不存在DOM操作。所以浏览器会并行下载其它含有defer标识的<script>。特别需要指明的是，defer脚本是会保证按引用顺序执行的。
3、	使用<script async></script>，一样会并行下载，但是不保证顺序执行，哪个先下载完，就执行哪个。但是一定会在派发onload事件之前全部加载执行完毕。
4、	使用JS往<head>中插入<script>标签的方式，进行异步的脚本加载，SeaJs使用的就是这种方式。
![没有图片](./pics/13.png)
5、	通过发送异步的Ajax请求加载js文件，然后通过eval执行。（不推荐）
#### 使用异步的Ajax请求 ####
1、	异步Ajax请求，然后通过回调函数执行响应处理，不会阻塞浏览器的执行。
2、	通过ES6的Promise对Ajax进行封装，起到更好的可读性。
### 减少HTTP请求的次数 ###
正如2.1中所说，HTTP建立连接是一个比较耗时的操作，所以减少HTTP的请求次数，也能有效的提升Web页面的性能。这也就是Webpack的一大特性之一，就是将文件根据依赖进行打包、整合。
### 压缩响应数据 ###
1、	Webpack支持对打包的文件，进行压缩，目的就是加快HTTP响应速度。
2、	系统接口返回的数据，如果很大的情况下，也可以进行压缩传输。
### 提取公共依赖，有效使用浏览器缓存 ###
一个Web应用，或多或少的，都用到一些第三方库或者是工具包，这些是会被各个页面共享的，所以可以将这部分内容提取出来，利用浏览器缓存机制，有效减少HTTP的传输内容。可以使用Webpack提取公共依赖。
### 动静态分离 ###
把Api接口和静态资源分开部署在不同的服务器，可以有效的提升应用服务器的响应能力。并且因为浏览器与服务器建立的长连接个数是有限的，通过多台服务器，也能有效的增加连接个数，相当于增加了传输通道，性能自然会提升。
### 用循环替代递归 ###
因为递归的过程是需要压栈和出栈的，递归就是函数不断调用自身的一个过程，每次调用时都要做地址保存，参数传递等，在层次较多的时候，不仅会耗费较大的存储空间，还可能照成堆栈溢出等现象。
### 使用浏览器本地存储 ###
以上所说的浏览器缓存，都指的是静态资源的，其实我们也可以使用localStorage和sessionStorage对后台返回的一些常量信息或者不长变化的信息做缓存，使用方式为setItem / getItem，它们能存储的大小都是5M，其中localStorage是永久存储的，除非主动删除，而sessionStorage只在当前会话窗口周期内有效。
### Vue框架使用优化 ###
1、	Object.freeze冻结不变的属性。
2、	对渲染一次之后不变的模板使用v-once。
3、	根据不同场景，选择使用v-show、v-if。
4、	在使用v-for的过程中，尽可能提高key的命中率。
5、	使用计算属性优化watch和method调用。
6、	使用异步组件来实现按需加载。
7、	结合vue的生命周期，将不影响组件表现的动作，放到挂载结束以后。
8、	将大数据的一次性渲染，拆分成多次小的渲染过程，已提升首帧的展示速度。
# Web安全问题 #
## XSS跨站脚本攻击 ##
1、	反射型攻击：对URL参数进行编码。
2、	存储型攻击：对表单数据进行编码。
3、	不直接将地址栏参数和用户数据，作为HTML插入到DOM文档中。
4、	增加必要的输入校验
5、	利用框架的相关机制进行保证，例如vue的{{文本}} ，{{{HTML}}}。
## CSFR跨站请求伪造 ##
假设不法份子架设了一个A网站，A网站有一个超链接直接指向<a href=’www.建设银行.com/转账/不法份子账户/金额100万’>，如果建设银行的转账接口就是 /转账/目标账户名/金额。
考虑以下一个场景，当你在一个浏览器内同时登录了建行的个人网上银行，同时打开了不法份子的网站，并且很不幸的点击了不法份子网页上的那个超链接，那么会发生什么事情？避免此类攻击的主要方式如下：	
1、	首先重要操作不使用GET，改用POST，因为GET请求及其容易伪造。【首先】
2、	不使用cookie，或者说不能单纯的依赖cookie做鉴权，因为cookie会在每次请求服务器的时候，由浏览器自动携带。【其次】
方案：
1、	将鉴权信息已token令牌的形式返回前端，前端将此令牌存储于缓存中，后续每次请求的时候，取出令牌组装到请求头中，后台通过校验此鉴权token是否合法，同时利用请求头的Referer ，用于校验请求来源是否合法。
2、	定义一套加密算法，这套算法的js源码本身也需要加密混淆，然后每次提交的数据都通过此加密算法加密，接收数据之后解密，解密失败则认为请求非法。这种方式对算法的安全性要求较高，无法百分百的保证算法不被破解，同时加解密操作相对来说比较耗时。
3、	当下最通用的方式是：登录完成后，由后台返回一个随机的鉴权标识给前端，前端将该标识存储于cookie中。利用浏览器下无法跨域读取资源的限制，所以攻击者无法得到此鉴权标识用于组装请求。后续每次请求后台数据的时候，都在http请求头中携带此鉴权标识。后台需要匹配头中的鉴权表示与cookie中的是否一致。当然此标识也可以跟请求数据的正文一起发送，不过这样需要对现有应用进行大量改动。
# TCP三次握手 #
TCP位码,有6种标示:
SYN(synchronous建立联机) 
ACK(acknowledgement 确认) 
PSH(push传送) 
FIN(finish结束) 
RST(reset重置) 
URG(urgent紧急)
![没有图片](./pics/14.png)
1、	客户端发送位码为SYN＝1（表示创建一个新连接）,随机产生seq number=j的数据包到服务器，客户端进入SYN_SENT状态，等待服务器的确认； 
2、	服务器由SYN=1知道客户端要求建立联机，所以会发送确认联机消息给客户端，首先会将客户端发送的seq + 1（此例为j+1）作为响应数据包的ack(确认)，同时随机产生一个响应数据包中的seq number=k，此时位码为SYN=1，ACK=1, 此时服务器进入SYN_RECV状态。
3、	客户端收到响应数据包后，首先检查ack是否正确（是否为j+1），以及位码ACK是否为1，如果都正确，则将服务器发来的seq+1（此例为k+1）作为数据包的ack（确认），此条消息的位码为ACK=1。服务器接收到消息后，对ack校验，如果正确，三次握手就完成了，连接也就建立成功了。
# JS中改变this指向 #
1、	call(obj, arg1, arg2, arg3 …)
2、	apply(obj, [arg1, arg2, arg3…])
以上两种方式，参数类型不一致，call需要列举参数，apply的参数用数组提供。
![没有图片](./pics/15.png)
3、	通过调用new创建对象的方式
![没有图片](./pics/16.png)
4、	ES6的箭头函数，可以让内部this与上层保持一致
5、	bind方法设置this
# 字符串反转 #
1、	'str'.split(''). reverse().join('') 利用数组反转
2、	生成新字符串，从原字符串的末尾开始往前遍历
# 数组去重 #
1、	利用Set结构，[…new Set([1, 1, 2, 3])]
2、	利用对象的key无法重复机制
3、	先对数组排序，然后比较相邻位
4、	双重循环，结合includes或者indexOf实现
# Flex布局问题 #
# 跨域问题 #
1、	jsonp的方式，通过设置callback回调函数，缺陷：只支持get的形式
2、	后台设置cros，列举出支持的域列表和方法名（GET/POST）
3、	跨域是浏览器的一种保护机制，请求还是到达了后台服务器，所以不能单纯的利用跨域来做权限控制。
# React与Vue的区别 #
1、	模板语法不同。Vue采用模板语法，类似于HTML形式的模板，只是增加了一些指令和属性。而React采用JSX语法，直接在js中写模板结构，相比较而言，React更灵活，但是Vue更利于理解，同时更容易上手。
2、	状态管理不同。React中的状态需要设置在state中，需要变更状态的话，需要通过setState方法。而Vue是通过data对象的存放状态，不需要通过set的方式更改。
3、	虚拟DOM实现不同。Vue会根据组件间的依赖关系，计算出最小的改动，尽可能的复用现有节点。而React会重新生成子组件。
# 驼峰标识转换 #
	var s = "fooStyleCss";
s = s.replace(/([A-Z])/g,"_$1").toLowerCase();
得到foo_style_css
也可以通过字符串遍历比较的方式
# 判断数组 #
![没有图片](./pics/17.png)
# DOM的原生基本操作 #
# DOM的重绘、重排 #
![没有图片](./pics/18.png)
如何优化？
1、	最小的重绘和重排，例如：需要对某个节点的样式进行多次变更，可以使用如下两种方式：
A、	通过cssText优化，element.style.cssText = cssText，用一次复制操作替代多次变动
B、	通过改变节点的class，直接一次性的对节点样式进行切换。
2、	批量修改DOM
A.	先隐藏元素，然后做完更改之后，重新显示元素
B.	将原始元素拷贝到一个脱离文档的节点中，修改副本，最后替换原始元素。
3、	让元素脱离动画流
A、	使用绝对定位
4、	减少使用:hover
IE中:hover会严重降低响应速度
# 同构，服务器端渲染 #
1、	主要用于解决SEO，利用搜索引擎进行宣传或者导流，企业级并不完全需要这种方式。
2、	服务器端渲染能有效提升初始渲染速度。
#  #Promise
A.	Promise.all用于实现多个异步操作执行完之后进行回调。
实现原理：用一个外层的Promise嵌套，设置一个标志n，内部的promise执行完之后，均执行n++，然后判断n是否等于内部promise的总个数，如果个数相同，则执行外层promise的resolve。
B.	Promise的then中如果抛出异常，一样可以在catch中获取到。
C.	Generator也是一种异步执行的方式，可以很好的进行步骤的控制，衍生出的async/await实现异步，只是Generator的语法糖实现。
# DOMContentLoaded和onload的区别 #
A.	DOMContentLoaded发生在dom构建完成之后，此时页面中的图片、视频等尚未加载完毕。
B.	onload会在所有资源加载完毕之后触发。
C.	DOMContentLoaded派发的比onload事件更早。
# Service Worker #
	1、因为js是单线程执行的，Service Worker可以提供一种多线程的编程方式，它是浏览器开启的一个后台线程，可以执行一些离线操作。当js在执行的时候，可以同时使用Service Worker进行其它的操作。
# 开速排序原理 #
	取一个基准数，比这个数小的，移动到左边，比这个数大的移动到右边。
	然后重复递归对左右两边进行同样的操作。
# 堆排序的原理 #
	构建一个大根堆，然后将首位与末尾交换，将末尾的索引前移一位。
	重复以上操作，直到末尾索引指向首位。

# 原生js实现ajax #
![没有图片](./pics/19.png)	 
# 浏览器cookie操作 #
	通过document.cookie进行赋值和修改
# 浏览器兼容性问题 #
1、	javascript相关
A、	事件绑定，IE是attachEvent，其它为addEventListener
B、	event（事件）的坐标问题
IE支持x、y，火狐不支持，可以使用clientX/clientY或者pageX/pageY实现
C、	es6语法支持问题，需要使用babel转码成es5
D、	事件源的获取方法不同，标准浏览器是event.target，而IE下是event.srcElement
E、	Ajax的实现方式不同，获取XMLHttpRequest的不同，IE下是ActiveXObject
2、	css相关
A、	盒子模型，padding和border的宽高与content的是否同时计算
B、	元素默认的padding和marging不一致，例如h1，可以统一设置padding和marging
C、	IE6双边距问题：IE6在浮动后，又有横向的margin，此时，该元素的外边距是其值的2倍
D、	IE6下无法设置1px的行高，原因是由其默认行高引起的       
 解决办法：为期设置overflow:hidden;或者line-height:1px;
# inline-block和float的区别 #
	两者都可以用来将块级元素显示在同一行上
1、	inline-block: 水平排列一行，即使元素高度不一，也会以高度最大的元素高度为行高，即使高度小的元素周围留空，也不回有第二行元素上浮补位。可以设置默认的垂直对齐基线。
2、	float: 让元素脱离当前文档流，呈环绕装排列，如遇上行有空白，而当前元素大小可以挤进去，这个元素会在上行补位排列。默认是顶部对齐。


	


		


	


	
